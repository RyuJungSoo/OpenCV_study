# 4.1 블러링
영상 처리에서 **공간적 필터링** 이란 입력 영상의 특정 위치의 픽셀 org(i, j) 또는 그 주변의 픽셀들까지 포함한 성분들에 
임의의 연산을 수행하여 그 결괏값을 목적 위치 res(i, j)에 대입하는 것이다.           
<img src="https://user-images.githubusercontent.com/81175672/179225235-68c60d35-2c60-4ed7-a025-8a246ed8c088.png"  width="500" height="300"/>               
여기서 연산을 위하여 사용하는 픽셀의 개수를 결정하는 것이 **필터의 크기** 이고, 필터 내부의 연산은 다양하게 정의할 수 있다.
위 그림은 필터링 예시이다. **필터의 값과 이 위치에 대응하는 입력의 값을 곱한 후에, 모든 값들을 합하여 출력의 빨간 박스 위치에 새로운 값을 대입하는 것** 으로 필터링을 할 수 있다.              
<img src="https://user-images.githubusercontent.com/81175672/179246348-58135e29-07b6-424c-a867-497f778808ea.gif"  width="500" height="300"/>  
이에 대한 수식은 아래와 같다.             
<img src="https://user-images.githubusercontent.com/81175672/179227549-4215f9d3-71a9-4784-b2a4-225232620705.JPG"  width="600" height="100"/>            
***
W<sub>f</sub>, H<sub>f</sub> -> 필터의 가로와 세로의 크기                            
v(w<sub>f</sub>, h<sub>f</sub>)는 필터 위치 (w<sub>f</sub>, h<sub>f</sub>)의 값이다.                              
필터의 크기가 커질수록 더 많은 주변 정보를 반영하여 새로운 값이 생성되고, 필터의 형태는 
1x3, 5x1, 5x5 등과 같이 매우 다양하게 정의될 수 있다.
***
**블러링(Blurring)** 은 필터링을 이용하여 영상을 부드럽게 만드는 기법으로 잡음 제거 등의 전처리 용도로도 사용하거나, 시간적인 효과를 위하여 사용하기도 한다. 
OpenCV에서는 **blur()** 라는 함수를 지원하며 평균값을 구하는 연산을 수행하기에 **평균 필터(Average Filter)** 라고 할 수 있다.           
***
## blur() 함수
**blur(src, ksize, dst=None, anchor=None, boarderType=None)**           
기능: 입력 영상(src)을 지정된 크기(ksize)의 필터를 기반으로 평균값을 처리한다.          
| 매개변수 | 의미 |
| --- | --- |
| src | 8/16/32/64 비트의 입력 영상 |
| dst | 입력 영상과 동일한 크기와 자료형을 가지는 출력 영상 |
| ksize | 필터의 크기 |
| anchor | 좌표의 원점 위치를 지정 ((-1,-1)이면, 필터의 중심을 원점으로 사용함) |
| boarderType | 영상의 가장 자리를 처리하는 방식 지정(BORDER_CONSTANT, BORDER_REPLICATE, BORDER_REFLECT, BORDER_WRAP 등이 있음) |
***
boarderType은 영상의 가장 자리와 같이 필터에 해당하는 영상의 픽셀이 존재하지 않을 때 처리 방식을 지정하는 것이다.       
**BORDER_REFLECT_101** - 인접한 픽셀의 다음 픽셀값을 대칭 방향으로 가져온다.             
**BORDER_REFLECT** - 인접한 픽셀부터 대칭으로 가져온다.            
**BORDER_REPLICATE** - 가장 가까운 픽셀의 값으로 나머지 공간을 채운다.          
**BORDER_WRAP** - 가장 멀리 있는 대칭 픽셀의 값부터 반대로 가져온다.          
**BORDER_CONSTANT** - 주어진 특정 값 c로 빈 곳을 채운다. 특정값이 주어지지 않는다면 0으로 채우게 된다.          
<img src="https://user-images.githubusercontent.com/81175672/179246264-3a1c1d3d-a28d-4c5d-be5d-ec8930711e26.jpg"  width="500" height="400"/>              
***
## boxFilter() 
OpenCV에서 blur() 함수는 동일한 역할을 수행할 수 있는 **boxFilter()** 가 있으며 원형은 아래와 같다. 이 함수에서 정규화를 진행하면 blur 함수와 동일한 결과를 얻게 된다.       
***
**boxFilter(src, ddepth, ksize, dst=None, anchor=None, normalize=None, boarderType=None)**             
기능: 입력 영상(src)을 지정된 크기(ksize)의 필터를 이용하여 옵션(normalize)에 따라 평균값을 계산하거나 합산한다.             
| 매개변수 | 의미 |
| --- | --- |
| ddepth | 출력 영상의 깊이를 지정 (-1이면 입력 영상과 동일함) |
| normalize | 정규화 여부를 지정(True 또는 False) |
***
blur() 함수와 boxFilter() 함수의 계산은 아래 수식과 동일하다.            
<img src="https://user-images.githubusercontent.com/81175672/179249648-8a182ec1-44e8-4df6-8524-9718650d3ce8.JPG"  width="600" height="100"/>           
***
## filter2D() 함수
추가적으로 **filter2D() 함수**가 있으며 원형은 아래와 같다. 
이 함수도 위의 수식과 동일한 연사을 수행하지만 **N = 1**이다. 위의 두 함수와의 차이점은 필터를 직접 만들어서 입력할 수 있다는 것이다. 
따라서 다양한 확률 분포의 형태를 필터로 사용할 수도 있다.             
***
**filter2D(src, ddepth, dst=None, anchor=None, delta=None, boarderType=None)**             
기능: 입력 영상(src)에 주어진 필터(kernel)를 적용한다.                       
| 매개변수 | 의미 |
| --- | --- |
| kernel | 단일 채널의 실수 원소를 가지는 필터 (convolution 또는 correlation kernel이라 함) |
| delta | 출력 결과에 추가적으로 더하는 값 |
***
```py
# 관련 라이브러리 선언
import numpy as np
import cv2
from imgRead import imgRead
from createFolder import createFolder

# 영상 읽기
img1 = imgRead("img8.jpg", cv2.IMREAD_GRAYSCALE, 320, 240)

# 필터 정의 및 블러링 수행
ksize1 = 3; ksize2 = 5; ksize3 = 7; ksize4 = 9
kernel = np.full(shape=[ksize4, ksize4], fill_value=1, dtype=np.float32) / (ksize4*ksize4) # 9x9 사이즈이면서 모든 값이 1/81인 필터

res1 = cv2.blur(img1, (ksize1, ksize1)) # 3x3 사이즈 필터로 블러링
res2 = cv2.blur(img1, (ksize2, ksize2)) # 5x5 사이즈 필터로 블러링
res3 = cv2.boxFilter(img1, -1, (ksize3, ksize3)) # 7x7 사이즈 필터로 블러링을 하며 출력 영상의 dtype는 img1과 같음
res4 = cv2.filter2D(img1, -1, kernel) # kernel 필터로 블러링을 하며 출력 영상의 dtype는 img1과 같음
res5 = cv2.boxFilter(img1, -1, (1, 21)) # 1x21 필터로 블러링을 하며 출력 영상의 dtype는 img1과 같음 

# 결과 영상 출력
displays = [("input1", img1),
            ("res1", res1),
            ("res2", res2),
            ("res3", res3),
            ("res4", res4),
            ("res5", res5)]

for (name, out) in displays:
    cv2.imshow(name, out)

# 키보드 입력을 기다린 후 모든 영상창 닫기
cv2.waitKey(0)
cv2.destroyAllWindows()

# 영상 저장
save_dir = './code_res_imgs/c2_blur'
createFolder(save_dir)
for (name, out) in displays:
    cv2.imwrite(save_dir+"/"+name+".jpg", out)

```
필터의 크기가 커질수록 **영상은 부드러워지지만 렌즈의 초점이 맞지 않는 것처럼 영상이 흐려지고, 사물 간의 경계가 모호해짐**을 확인할 수 있다.                
정사각형 형태의 필터뿐만 아니라 직사각형 형태의 필터도 적용이 가능 -> 세로축의 값들만으로 평균한 값을 사용하기 때문에 **흔들리는 것**처럼 보이는 결과를 얻게 된다.          

## 출력 결과
<입력 영상>            
<img src="https://user-images.githubusercontent.com/81175672/179349556-6dad254b-b5b8-4300-8e97-e95035535b75.jpg  width="320" height="240"/>               
<3x3 필터>                  
<img src="https://user-images.githubusercontent.com/81175672/179349570-e39b3fe4-91b8-46de-9c32-3b6ddf71699f.jpg"  width="320" height="240"/>                     
<5x5 필터>                   
<img src="https://user-images.githubusercontent.com/81175672/179349745-53dbdf5e-841d-4e65-b3e3-14e81b9b206d.jpg"  width="320" height="240"/>  
<7x7 필터>            
<img src="https://user-images.githubusercontent.com/81175672/179349787-fa2690c3-d567-4bc3-b164-3f6e13edfe84.jpg"  width="320" height="240"/>  
<9x9 사이즈이면서 모든 값이 1/81인 필터>                   
<img src="https://user-images.githubusercontent.com/81175672/179349809-c58dc648-00b9-4727-b4da-d087ee64e21a.jpg"  width="320" height="240"/>  
<1x21 필터>                   
<img src="https://user-images.githubusercontent.com/81175672/179349835-b337048c-2bb7-4ceb-9ead-ca371760d718.jpg"  width="320" height="240"/> 
