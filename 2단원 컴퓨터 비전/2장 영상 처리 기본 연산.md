# 2.1 산술 및 논리 연산
영상을 **일정 크기의 모눈종이에 기록된 숫자의 모음**이라고 생각해 보자. 이는 영상 해상도 개념을 생각하면 직관적으로 받아들일 수 있을 것이다.      
즉, 특정한 크기의 공간에 순서가 유의미한 값들이 채워져 있는 것이다. 이를 **수학적**으로 생각하면, w x h x c 행렬에, 원소는 [0, 255] 범위의 값을 가지도록 한정한 것이라고 할 수 있다.
w, h는 영상의 폭과 높이이고, c는 채널의 개수이다. 따라서 영상을 **행렬 형태**로 표현하고 행렬 간의 연산을 통하여 새로운 영상을 생성하거나, 다양한 영상 처리를 수행할 수 있다.       
***
## 산술 연산
**산술 연산**은 행렬 간의 사칙연산을 수행하는 것으로, 두 영상의 픽셀 간에 연산이 적용된다.            
(ex. 덧셈 연산)       
<img src="https://user-images.githubusercontent.com/81175672/178151353-b21d9486-eeb0-4174-acf1-943e00a553bb.JPG"  width="500" height="100"/>            
***
org<sub>1</sub>, org<sub>2</sub> -> 입력 영상               
(i, j) -> 픽셀 위치             
res -> 덧셈 연산의 결과 영상                   
두 영상을 더하게 되면 픽셀이 가질 수 있는 최댓값인 255를 초과할 수도 있으며, 이를 위한 예외 처리를 해주어야 한다.(뺄셈의 경우 0보다 작은 값이 발생할 수도 있음.)      
***
**내장함수**가 예외 처리를 수행해 주지만, Numpy 등의 다른 라이브러리를 사용할 경우에는, 예외 처리를 위한 코드를 추가해야 한다.
파이썬에서는 한 픽셀에 할당된 자료형의 값 범위를 순환적으로 사용하고, OpenCV에서는 자료형이 가질 수 있는 **최솟값**과 **최댓값**을 사용하여 범위 밖의 값을 이들 값으로 대체한다.   ***  
한 픽셀에 8비트([0, 255])의 값이 할당되었다고 가정할 때 OpenCV는 입력이 **0보다 작으면 0, 255보다 크면 255**를 출력 값으로 하는데 반해, 
파이썬은 입력이 0보다 작거나 255보다 크더라도 값을 포화시키지 않는다.          
<img src="https://user-images.githubusercontent.com/81175672/178172415-a3cf0a5d-d459-4300-b7ab-af108e3732d2.jpg"  width="500" height="500"/>                    
(ex. 입력 영상이 3x3x1이므로 이 둘의 덧셈 연산을 수행한 결과 영상도 3x3x1이다.)       
덧셈 연산을 기반으로 두 영상을 중첩하여 표현할 수 있다. OpenCV에서는 이에 대한 add() 함수와 addWeighted() 함수를 제공한다.         
***
### <덧셈 연산>
#### -add() 함수-
**add(src1, src2, dst=None, dtype=None)**         
연산: dst <- src1 + src2             
| 매개변수 | 의미 |
| --- | --- |
| src1 | 첫 번째 입력 행렬 또는 스칼라 |
| src2 | 두 번쨰 입력 행렬 또는 스칼라 |
| dst | 결과 행렬 (입력 행렬과 동일한 크기와 채널 수를 가짐. 깊이는 입력 행렬의 깊이와 같거나 dtype에 의해 결정됨.) |
| mask | mask 행렬 원소가 0이 아닌 위치에서만 연산 수행 (8비트 1채널 행렬), None일 경우에는 영상 전체에 대하여 연산 수행함. |
| dtype | 결과 행렬의 깊이 |

#### -addWeighted() 함수-
**addWeighted(src1, alpha, src2, beta, gamma, dst=None, dtype=None)**         
연산: dst <- (src1 x alpha) + (src2 x beta) + gamma                     
| 매개변수 | 의미 |
| --- | --- |
| alpha | src1의 가중치 |
| beta | src2의 가중치 |
| gamma | 가중합의 결과에 추가적으로 더하는 값 |        
***
add() 함수를 사용하였을 경우에는 **결괏값이 255 이상인 픽셀들이 다수 존재**하기에 영상이 빛바래 보인다. 반면에 addWeighted()의 경우에는 alpha와 beta의 합이 1이 되도록 
사용하여 포화된 영역이 없이 자연스럽게 표시되었다.

### 출력 결과
<입력 영상>            
<img src="https://user-images.githubusercontent.com/81175672/178249949-a97bd68b-d6a5-4e0c-aaea-e91d1cc3bafa.jpg"  width="300" height="300"/>               
<확률 지도>                  
<img src="https://user-images.githubusercontent.com/81175672/178250469-87b019c7-72ac-4e79-a3a6-3ba6c3c70c77.jpg"  width="300" height="300"/>                     
<덧셈>                   
<img src="https://user-images.githubusercontent.com/81175672/178250592-a2a0d421-d24c-4038-950f-39f8da35c9f7.jpg"  width="300" height="300"/>                     
<가중 덧셈>                  
<img src="https://user-images.githubusercontent.com/81175672/178250724-0012eeee-49ea-4494-824a-29bb307620e6.jpg"  width="300" height="300"/>                  

***
### <뺄셈 연산>
뺄셈 연산은 두 이미지 간의 차이를 찾는데 유용하다. OpenCV에서 subtract() 함수와 absdiff() 함수를 활용할 수 있다.            
#### -subtract() 함수-
**subtract(src1, src2, dst=None, mask=None, dtype=None)**         
연산: dst <- src1 - src2  

#### -absdiff() 함수-
**subtract(src1, src2, dst=None, mask=None, dtype=None)**         
연산: dst <- ||src1 - src2||          

### 출력 결과
<입력 영상1>            
<img src="https://user-images.githubusercontent.com/81175672/178251365-99ca115d-f157-42bf-8020-74ccabc571ac.jpg"  width="300" height="300"/>               
<입력 영상2>                  
<img src="https://user-images.githubusercontent.com/81175672/178251445-2364852f-51e7-4c04-ac71-1c055bfc001a.jpg"  width="300" height="300"/>                     
<뺄셈>                   
<img src="https://user-images.githubusercontent.com/81175672/178251527-16016933-8ce7-49cb-930d-af0bd89a15f4.jpg"  width="300" height="300"/>                     
<대치>                  
<img src="https://user-images.githubusercontent.com/81175672/178251613-88be01f6-a718-4e68-b1c3-d36a7bb04b68.jpg"  width="300" height="300"/>   

***
subtract() 함수는 0 이하는 모두 0으로 대치하기에 두 입력 영상의 차가 음수인 경우에는 눈으로 확인할 수가 없다. 반면에 absdiff()는 두 입력 영상의 차이를 절대치를 반환하기에 
두 영상이 다른 부분이 명확히 보인다. 
***
### <곱셈 & 나눗셈 연산>
#### -multiply() 함수-
**multiply(src1, src2, dst=None, scale=None, dtype=None)**         
연산: dst <- scale x src1 x src2         
| 매개변수 | 의미 |
| --- | --- |
| scale | 두 입력의 곱에 추가적으로 곱하는 값 |
***
#### -divide() 함수-
**multiply(src1, src2, dst=None, scale=None, dtype=None)**         
연산: dst <- scale x src1 / src2       

## <논리 연산>                
**논리 연산**은 행렬 간의 논리합(OR), 논리곱(AND), 부정(NOT), 배타적 논리합(XOR)을 수행한다.         
논리 연산도 픽셀 간에 연산이 적용되지만, 픽셀값을 이진수로 변환 후 비트 단위로 연산을 수행한다.                                     
<img src="https://user-images.githubusercontent.com/81175672/178226407-ac6d64bf-7e54-4dde-bbc0-78ab3c3350c0.JPG"  width="600" height="200"/>               
OpenCV에서는 bitwise_and(), bitwise_not(), bitwise_or(), bitwise_xor()의 논리 연산 함수를 제공하며 원형은 아래와 같다.           
***
**bitwise_and(src1, src2, dst=None, maks=None)**             
**bitwise_not(src, dst=None, mask=None)**             
**bitwise_or(src1, src2, dst=None, mask=None)**            
**bitwise_xor(src1, src2, dst=None, mask=None)**            
***
논리 연산은 산술 연산에 비하여 결과 영상을 직관적으로 예측하기 어렵지만, 몇 가지 경우에 유용하게 사용될 수 있다.           
(ex 1. 부정 연산을 통한 영상 반전 -> 정해진 구간을 반으로 접는다고 가정하면 부정 연산은 서로 마주보는 값을 출력하며 이는 영상 반전과 동일한 결과)              
(ex 2. 마스크 처리 - 논리곱을 이용하여 특정 영역만을 남기고 나머지는 표시하지 않는 방법 -> 표시시키고 싶지 않은 부분을 00000000(0)과 논리곱, 나머지는 11111111(255)과 논리곱)               
### 출력 결과
<입력 영상>            
<img src="https://user-images.githubusercontent.com/81175672/178252054-678be877-a0e0-4a58-bd7d-a0b2a7c63e06.jpg"  width="300" height="300"/>               
<NOT 연산>                  
<img src="https://user-images.githubusercontent.com/81175672/178252098-5ca67221-43c9-4ae6-a90e-c8e31ed438ed.jpg"  width="300" height="300"/>                     
<AND 연산>                   
<img src="https://user-images.githubusercontent.com/81175672/178253370-cab80339-1a18-4874-abe3-57f3720310e8.jpg"  width="300" height="300"/>    

```py
import numpy as np
import cv2
from imgRead import imgRead
from createFolder import createFolder

# 영상 읽기
img1 = imgRead("img1.jpg", cv2.IMREAD_UNCHANGED, 320, 240)
img2 = imgRead("img2.jpg", cv2.IMREAD_UNCHANGED, 320, 240)
img3 = imgRead("img3.jpg", cv2.IMREAD_UNCHANGED, 320, 240)
img4 = imgRead("img4.jpg", cv2.IMREAD_UNCHANGED, 320, 240)
img5 = imgRead("img5.jpg", cv2.IMREAD_GRAYSCALE, 320, 240)

# 마스크 선언 및 초기화
mask = np.full(shape=img5.shape, fill_value=0, dtype=np.uint8) # 모든 값이 0인 행렬
h, w = img5.shape # img5의 크기
x = (int)(w/2) - 60; y = (int)(h/2) - 60 # 남길 부분의 시작부분
cv2.rectangle(mask, (x,y), (x+120, y+120), (255, 255, 255), -1) # mask에 남길 부분의 시작부분으로부터 가로, 세로 120이고 안이 하얀색으로 꽉 찬 사각형 만들기

# 산술 및 논리 연산 수행
ress = []
ress.append(cv2.add(img1, img2)) # img1와 img2를 더한 다음 ress에 추가
ress.append(cv2.addWeighted(img1, 0.5, img2, 0.5, 0)) # img1와 img2에 가중치 0.5만큼 곱한 다음 더하기, 그 다음 ress에 추가
ress.append(cv2.subtract(img3, img4)) # img3에서 img4를 뺸 다음 ress에 추가
ress.append(cv2.absdiff(img3, img4)) # img3에서 img4를 뺀 다음 그 절댓값을 ress에 추가
ress.append(cv2.bitwise_not(img5)) # img5의 부정을 ress에 추가
ress.append(cv2.bitwise_and(img5, mask)) # img5와 mask를 AND한 것을 ress에 추가

# 결과 영상 출력
displays = [("input1", img1),
            ("input2", img2),
            ("input3", img3),
            ("input4", img4),
            ("input5", img5),
            ("res1", ress[0]),
            ("res2", ress[1]),
            ("res3", ress[2]),
            ("res4", ress[3]),
            ("res5", ress[4]),
            ("res6", ress[5]),]
for (name, out) in displays:
    cv2.imshow(name, out)

# 키보드 입력을 기다린 후 모든 영상창 닫기
cv2.waitKey(0)
cv2.destroyAllWindows()

# 영상 저장
save_dir = './code_res_imgs/c2_arithmeticLogical'
createFolder(save_dir)
for (name, out) in displays:
    cv2.imwrite(save_dir+"/"+name+".jpg", out)

```
