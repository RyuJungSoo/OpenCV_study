# 6.1 미분 연산 기반의 에지 검출
**에지(Edge)** 는 주로 객체의 윤곽이나 급격히 변화되는 부분에 해당하는 것으로, 영상에서는 이웃한 픽셀들과 값 차이가 큰 픽셀이 여기에 해당된다.                  
주변 픽셀과의 값 변화 차이를 계산하기 위하여 **미분(Differentiation) 연산** 을 이용한다.                
<img src="https://user-images.githubusercontent.com/81175672/180767846-b7f8be54-d281-488c-91b2-f8c7ed4bf929.JPG"  width="700" height="150"/>         
<img src="https://user-images.githubusercontent.com/81175672/180775609-ac7928ba-fbd4-4106-892b-4ad7bc1f5af6.JPG"  width="900" height="100"/>   
위 수식을 도함수라고 하며 구하고자 하는 성분인 미분계수를 함수화하여 표시한 형태이다. 이는 y=f(x)의 그래프 위의 임의의 점(x,f(x))에 대한 접선의 기울기이다.        
영상 처리에서는 위의 수식을 근사화하여 사용하는 것이 일반적이다. **변화량 Δx는 좌표의 변화, Δy는 이에 해당하는 픽셀값의 변화량으로 볼 수 있다.**  즉 특정 픽셀의 좌우 또는 위아래에 위치한 픽셀값의 차이를 통하여 기울기를 알 수 있다. Δx = 1일 때, 2차 미분을 구하면 다음과 같다.
<img src="https://user-images.githubusercontent.com/81175672/180777465-3f41e9ee-7231-4edc-ac17-eecefc27c152.JPG"  width="1000" height="300"/>                
(증명하려면 수치해석, 테일러 급수 써야하는 거 같아보임......[참고자료](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=y244&logNo=221067641890))       
***
영상은 2차원 공간에 표현되는 정보이다. 따라서 **2개의 미분계수** 를 이용하여 기울기를 표현한다.                         
**가로축** 에 대해서만 미분을 하게 되면 세로 방향으로 발생하는 에지만을 검지하게 되고,                       
**세로축** 에 대해서만 미분을 하게 되면 가로 방향으로 발생하는 에지만을 검지한다.                
두 방향 모두를 미분한다면 모든 에지를 검지할 수 있다. (그래서 **편미분** 이 필요. x, y 따로 미분)                      
영상에 대하여 가로축(i)과 세로축(j)에 대하여 편미분하여 하나의 벡터로 표현한 것을 **그레디언트(Gradient)** 라고 한다. 이는 아래와 같이 표현하며, 여기서 ∇는 그레디언트이고,
||  ||와 θ는 **크기(Magnitude)** 와 **방향(Direction)** 을 의미한다.
<img src="https://user-images.githubusercontent.com/81175672/180808403-ce254472-b4e0-437d-bd3b-7b8d7e5afce6.JPG"  width="900" height="200"/>   
***
OpenCV에서는 미분 연산을 기반으로 에지를 검지하는 **Sobel(), Scharr(), Laplacian() 함수** 를 제공한다. 필터 크기가 3x3과 같이 작을 때는 Scharr 방법이 Sobel 방법보다 더 정밀한 
결과를 반환한다. Sobel() 함수의 인자 ksize에 cv2.FITER_SCHARR 또는 -1을 지정하면 Scharr 마스크가 적용된다.                

**Sobel(src, ddepth, dx, dy, dst=None, ksize=None, scale=None, delta=None, borderType=None)**
연산: 입력 영상에 소벨 마스크를 적용하여 미분한다.                
| 매개변수 | 의미 |
| --- | --- |
| src | 입력 영상 |
| ddepth | 출력 영상의 깊이 |
| dx | 가로축(x)의 미분 차수 |
| dy | 세로축(y)의 미분 차수 |
| dst | 결과 영상 (입력 행렬과 동일한 크기와 채널의 수를 가짐) |
| ksize | 소벨 영산을 위한 필터 크기 |
| scale | 필터의 출력값에 추가적으로 곱하는 값 |
| delta | 필터의 출력값에 추가적으로 더하는 값 |
| borderType | 영상의 가장 자리를 처리하는 방식 지정 |
***
**Scharr(src, ddepth, dx, dy, dst=None, scale=None, delta=None, borderType=None)**                           
연산: 입력 영상에 샤르 마스크를 적용하여 미분한다.                                             
**Laplacian(src, ddepth, dst=None, ksize=None, scale=None, delta=None, borderType=None)**                                
연산: 입력 영상에 라플라시안 마스크를 적용하여 미분한다.                                       

3x3 필터를 사용할 때 각 함수는 아래 그림의 마스크를 가진다. Sobel과 Scharr은 **가로**와 **세로** 방향에 대한 각각의 마스크가 적용 가능하며, 
Laplacian은 **양방향**을 함께 고려한다.                    
<img src="https://user-images.githubusercontent.com/81175672/180905395-0f56e68d-8187-4fe9-87a1-63aa99b57da4.JPG"  width="900" height="300"/>           
```py
# 관련 라이브러리 선언
import numpy as np
import cv2
from imgRead import imgRead
from createFolder import createFolder

# 영상 읽기
img1 = imgRead("img16.jpg", cv2.IMREAD_GRAYSCALE, 320, 240)

# 에지 추출
img1_blue = cv2.GaussianBlur(img1, (3,3), 0)
res1 = cv2.Sobel(img1, cv2.FILTER_SCHARR, 1, 0, ksize=3) # Sobel 방법에 의한 가로 방향의 에지
res2 = cv2.Scharr(img1_blue, cv2.CV_32FC1, 0, 1) # Scharr 방법을 적용한 세로 방향의 에지
res3 = cv2.Laplacian(img1_blue, cv2.CV_32FC1) # Laplacian() 함수에 의한 에지
res4 = cv2.Canny(img1, 50, 200, apertureSize=5, L2gradient=True) # 케니 에지 검출기에 의한 에지

# 결과 영상 출력
displays = [("input1", img1),
            ("input2", img1_blue),
            ("res1", res1),
            ("res2", res2),
            ("res3", res3),
            ("res4", res4)]

for (name, out) in displays:
    cv2.imshow(name, out)

# 키보드 입력을 기다린 후 모든 영상창 닫기
cv2.waitKey(0)
cv2.destroyAllWindows()

# 영상 저장
save_dir = "./code_res_imgs/c2_edge"
createFolder(save_dir)
for (name, out) in displays:
    cv2.imwrite(save_dir + "/" + name + ".jpg", out)

```
## 출력 결과
<입력 영상>            
<img src="https://user-images.githubusercontent.com/81175672/180914703-12811f8a-3017-4b3c-a7f6-018e7b6d73ba.jpg"  width="320" height="240"/>               
<가우시안 블러링을 한 입력 영상>                  
<img src="https://user-images.githubusercontent.com/81175672/180914727-e23d68e4-5fdf-413c-be96-9699d0d9ef06.jpg"  width="320" height="240"/>                     
<Sobel(dx = 1)>                   
<img src="https://user-images.githubusercontent.com/81175672/180915109-52d706d3-a822-4e3b-b145-d2f0c58fdb31.jpg"  width="320" height="240"/>  
<Scharr(dy = 1)>                   
<img src="https://user-images.githubusercontent.com/81175672/180915125-16a5160c-f688-456f-a4e6-6c54eba3b372.jpg"  width="320" height="240"/>  
<Laplacian>                   
<img src="https://user-images.githubusercontent.com/81175672/180915168-fd6a1458-f305-4df0-bfb2-351a4ceffb33.jpg"  width="320" height="240"/>           
 <Canny>                   
<img src="https://user-images.githubusercontent.com/81175672/180915193-3be478c0-cf26-4417-bc1d-5f1e456b1c5a.jpg"  width="320" height="240"/>             
